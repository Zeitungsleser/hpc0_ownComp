@ <stdio.hdr>

@ "gen.hdr"
@ "genvar.hdr"

global usedReg: array[16] of bool;

fn getReg(): GenReg
{
    for (local r: GenReg = 3; r < sizeof(usedReg)/sizeof(usedReg[0]); ++r){
        if (!usedReg[r]) {
            usedReg[r] = true;
            return r;
        }
    }
    assert(0 && "getReg: out of registers!\n");
    return 0;
}

fn genReleaseReg(reg:GenReg)
{
    assert(usedReg[reg]);
    usedReg[reg] = false;
}

fn genConstant(val: -> UStr): GenReg
{
    local reg: GenReg = getReg();
    printf("\tload %s, %%%d\n", val, reg);
    return reg;
}

fn genInstrToStr(instr: GenInstr): -> char
{
    local str: -> char = "??";
    switch(instr){
        case GEN_ADD: str = "add"; break;
        case GEN_SUB: str = "sub"; break;
        case GEN_MUL: str = "mul"; break;
        case GEN_DIV: str = "div"; break;
    }
    return str;
}

fn genInstr(instr: GenInstr, left: GenReg, right: GenReg): GenReg
{
    local reg: GenReg = getReg();
    printf("\t%s %%%d, %%%d, %%%d\n", genInstrToStr(instr), right, left, reg);
    return reg;
}

fn genHalt(exitCode: GenReg)
{
    printf("\thalt %%%d\n", exitCode);
}

fn genLoadAddress(varName: -> UStr): GenReg
{
    genAddGlobalVar(varName);
    local reg: GenReg = getReg();
    printf("\tload %s, %%%d\n", varName, reg);
    return reg;
}

fn genFetch(addr: GenReg): GenReg
{
    local reg: GenReg = getReg();
    printf("\tmovq (%%%d), %%%d\n", addr, reg);
    return reg;
}

fn genStore(val: GenReg, addr: GenReg)
{
    printf("\tmovq %%%d, (%%%d)\n", val, addr);
}

//-- handle functions

fn genInit() {
    printf("\t.equ SP, 1\n\t.equ FP, 2\n\t.equ retval, 16\n\t.text\n\tload 0, %%SP\n");
    genPrepareFunctionCall(0);
    local reg: GenReg = genExecuteFunctionCall(UStrCreate("main"), 0);
    printf("\thalt %%%d\n", reg);
    genReleaseReg(reg);
    
    genBeginFunctionDefinition("getchar");
    printf("\tgetc    %%3\n");
    genEndFunctionDefinition();
    
    genBeginFunctionDefinition("putchar");
    printf("\tload    PUTCHAR,    %%3\n\tmovq    (%%3),    %%3\n\tputc    %%3\n");
    genEndFunctionDefinition();
    
    genAddGlobalVar(UStrCreate("PUTCHAR"));
}

fn genBeginFunctionDefinition(name: -> UStr) {
    printf("%s:\n\tmovq    %%3,          (%%SP)\n\tmovq    %%FP,         8(%%SP)\n\tmovq    %%SP,         %%FP\n\t// begin function body\n", name);
}

fn genEndFunctionDefinition() {
    printf("\t// store return value\n\tmovq    %%3,          retval(%%FP)\n\t// end function body\n\tmovq    %%FP,         %%SP\n\tmovq    8(%%SP),      %%FP\n\tmovq    (%%SP),       %%3\n\tret     %%3\n");
}

fn genPrepareFunctionCall(numArgs: int) {
    printf("\tsub     8*(3 + %d),   %%SP,         %%SP\n", numArgs);
}

fn genExecuteFunctionCall(name: -> UStr, numArgs: int): GenReg {
    local reg: GenReg = getReg();
    printf("\tcall    %s,          %%3\n\tmovq    retval(%%SP),  %%%d\n\tadd     8*(3 + %d),    %%SP,          %%SP\n", name, reg, numArgs);
    return reg;
}
