@ <stdio.hdr>
@ "parser.hdr"
@ "lexer.hdr"

fn parseStatement(): -> Expr;
fn parseCompoundStatement(): bool;
fn parseWhileStatement(): bool;
fn parseExprStatement(): bool;
fn parseExpr(): -> Expr;
fn parseAdditive(): -> Expr;
fn parseTerm(): -> Expr;
fn parseUnary(): ->Expr;
fn parseFactor(): -> Expr;
fn getExprKindFromToken(: Token): ExprKind;

fn parseProg(): array[10] of -> Expr
{
    local exprs: array[10] of -> Expr;
    local i : int = 0;
    while(i<10){
        local expr: -> Expr = parseStatement();
        if(!expr) {
            break;
        }
        exprs[i] = expr;
        i++;
    }
    return exprs;
}

fn parseFunction(): bool
{
    if (token.kind != FN){return false;}
    getToken();
    if (token.kind != IDENTIFIER) {
        printf("%u.%u function name expected \n", token.pos.row, token.pos.col);
        return false;
    }
    genBeginFunctionDefinition(token.val);
    getToken();
    if (!parseCompoundStatement()){
        printf("%u.%u compound expression expected \n", token.pos.row, token.pos.col);
        return false;
    }
    genEndFunctionDefinition();
    return true;
}

fn parseCompoundStatement(): bool
{
    if (token.kind != LBRACE){return false;}
    getToken();
    while(parseExprStatement() || parseCompoundStatement() || parseWhileStatement()){}
    if (token.kind != RBRACE) {
        printf("%u.%u '}' expected \n", token.pos.row, token.pos.col);
        return false;
    }
    getToken();
    return true;
}

fn parseWhileStatement(): bool
{
    static count: int = 0;
    if (token.kind != WHILE){return false;}
    getToken();
    ++count;
    printf("while%d:\n", count);
    if (token.kind != LPAREN){
        printf("%u.%u '(' expected \n", token.pos.row, token.pos.col);
        return false;        
    }
    getToken();
    local expr: -> Expr = parseExpr();
    if(!expr) {
        printf("%u.%u expression expected \n", token.pos.row, token.pos.col);
        return false;
    }
    if (token.kind != RPAREN){
        printf("%u.%u ')' expected \n", token.pos.row, token.pos.col);
        return false;        
    }
    getToken();
    local reg: GenReg = loadExpr(expr);
    printf("\tsub %%0, %%%d, %%0\n", reg);
    printf("\tjz done%d\n", count);
    genReleaseReg(reg);
    
    if(!parseCompoundStatement()) {
        printf("%u.%u compound expression expected \n", token.pos.row, token.pos.col);
        return false;           
    }
    printf("\tjmp while%d\n", count);
    printf("done%d:\n", count);
    return true;
}

fn parseExprStatement(): bool
{
    local expr: -> Expr = parseExpr();
    if(!expr){return false;}
    if (token.kind != SEMICOLON) {
        printf("%u.%u ';' expected \n", token.pos.row, token.pos.col);
        return false;
    }
    getToken();
    genReleaseReg(loadExpr(expr));
    return true;
}

fn parseStatement(): -> Expr
{
    local expr: -> Expr = parseExpr();
    if (!expr) {
        return nullptr;
    }
    if (token.kind == SEMICOLON){
        getToken();
        return expr;
    }else{
        getToken();
        printf("%u.%u ';' expected \n", 
                token.pos.row, token.pos.col);
        assert(0);
        return nullptr;
    }
}

fn parseExpr(): -> Expr
{
    local left: -> Expr = parseAdditive();
    if (!left) {
        return nullptr;
    }
    while (token.kind == EQUAL) {
        local symbol: ExprKind = getExprKindFromToken(token);
        getToken();
        local right: -> Expr = parseExpr();
        if (!right) {
            printf("%u.%u expected additive\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        left = createBinaryExpr(symbol, left, right);
    }
    return left;
}

fn parseAdditive(): -> Expr
{
    local left: -> Expr = parseTerm();
    if (!left) {
        return nullptr;
    }
    while (token.kind == PLUS || token.kind == MINUS) {
        local symbol: ExprKind = getExprKindFromToken(token);
        getToken();
        local right: -> Expr = parseTerm();
        if (!right) {
            printf("%u.%u expected term\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        left = createBinaryExpr(symbol, left, right);
    }
    return left;
}

fn parseTerm(): -> Expr
{
    local left: -> Expr = parseUnary();
    if (!left) {
        return nullptr;
    }
    while (token.kind == ASTERISK || token.kind == SLASH) {
        local symbol: ExprKind = getExprKindFromToken(token);
        getToken();
        local right: -> Expr = parseUnary();
        if (!right) {
            printf("%u.%u expected term\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        left = createBinaryExpr(symbol, left, right);
    }
    return left;
}

fn parseUnary(): -> Expr
{
    if (token.kind == ASTERISK || token.kind == AMPERSAND){
        local symbol: TokenKind = token.kind;
        getToken();
        local child: -> Expr = parseUnary();
        switch (symbol){
            case ASTERISK: return createUnaryExpr(EXPR_DEREF, child);
            case AMPERSAND:{
                if (!addressableExpr(child)){
                    printf("%u.%u: expression has no address\n",
                        token.pos.row, token.pos.col);
                    return nullptr;
                }
                return createUnaryExpr(EXPR_ADDR, child);
            } 
            default: return nullptr;
        }
    } else {
        return parseFactor();
    }
}

fn parseFactor(): -> Expr
{
    if (token.kind == DECIMAL_LITERAL) {
        local expr: -> Expr = createIntegerExpr(token.val);
        getToken();
        return expr;
    } else if (token.kind == LPAREN) {
        getToken();
        local expr: -> Expr = parseExpr();
        if (!expr) {
            printf("%u.%u expected expression\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        if (token.kind != RPAREN) {
            printf("%u.%u expected ')'\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        getToken();
        return expr;
    } else if (token.kind == IDENTIFIER) {
        local val: -> UStr = token.val;
        getToken();
        if (token.kind == LPAREN){
            getToken();
            if (token.kind != RPAREN){
                printf("%u.%u: ')' expected\n", token.pos.row, token.pos.col);
                return nullptr;
            }
            getToken();
            return createCallExpr(val);
        }else{
            return createIdentifierExpr(val);
        }
    } else {
        return nullptr;
    }
}

fn getExprKindFromToken(tok: Token): ExprKind
{
    switch(tok.kind){
        case ASTERISK: return EXPR_MUL;
        case SLASH: return EXPR_DIV;
        case PLUS: return EXPR_ADD;
        case MINUS: return EXPR_SUB;
        case EQUAL: return EXPR_ASSIGN;
        default:
            assert(0 && "internal error: exprKindFromToken\n");
            return 0;
    }
}
